{
  "project": {
    "languages": ["JavaScript", "TypeScript", "CSS", "SQL", "HTML"],
    "size_bytes": 1988678,
    "entry_points": [
      "client/src/app/layout.js",
      "server/src/index.js"
    ],
    "total_files": 250,
    "backend_routes_count": 41,
    "frontend_components_count": 143,
    "backend_services_count": 38,
    "database_models": 47,
    "frameworks": [
      "Next.js 14.x",
      "React 18.x",
      "Express.js 4.18.3",
      "Prisma ORM 7.1.0",
      "PostgreSQL 8.11"
    ],
    "ui_framework": "Tailwind CSS + Radix UI",
    "state_management": "Zustand",
    "websocket": "Socket.io 4.7.4",
    "build_commands": {
      "frontend": "npm run build (Next.js)",
      "backend": "npm start:prod",
      "test": "npm run test:comprehensive"
    }
  },
  "findings": [
    {
      "id": "F-0001",
      "severity": "High",
      "confidence": "High",
      "title": "Missing Input Validation on Public Widget Chat Endpoint",
      "description": "POST /api/widget/chat lacks request body schema validation. Accepts arbitrary JSON data without size or structure validation, allowing malformed or oversized requests to reach AI processing layer, causing potential DoS.",
      "impact": "Attackers can send oversized payloads (>10MB) or deeply nested JSON to crash widget chat service or cause resource exhaustion.",
      "files": [
        {
          "path": "server/src/routes/widget.routes.js",
          "start_line": 141,
          "end_line": 141,
          "snippet": "router.post('/chat', widgetChatLimiter, asyncHandler(chatController.sendMessage));"
        },
        {
          "path": "server/src/controllers/chat.controller.js",
          "start_line": 1,
          "end_line": 50,
          "snippet": "// No input validation - accepts req.body directly"
        }
      ],
      "remediation": "Add Zod/express-validator schema validation middleware to validate message payload structure, length (max 2000 chars), and required fields before processing.",
      "tags": ["security", "validation", "input", "dos"],
      "affected_users": "All widget users",
      "business_impact": "Service availability risk"
    },
    {
      "id": "F-0002",
      "severity": "High",
      "confidence": "High",
      "title": "Insufficient Password Reset Rate Limiting",
      "description": "POST /api/auth/forgot-password lacks rate limiting. Attackers can brute-force email addresses or conduct spam attacks by requesting password resets for arbitrary accounts without frequency limits.",
      "impact": "Account enumeration (determine valid emails), email spam attacks, customer spam harassment.",
      "files": [
        {
          "path": "server/src/routes/password.routes.js",
          "start_line": 9,
          "end_line": 15,
          "snippet": "router.post('/forgot-password', async (req, res) => {\n  const { email } = req.body;\n  // No rate limiting - accepts unlimited requests per email"
        }
      ],
      "remediation": "Implement rate limiting using express-rate-limit: max 3 attempts per email per hour, max 10 attempts per IP per hour. Add CAPTCHA verification after 2 failed attempts.",
      "tags": ["security", "rate-limit", "brute-force", "authentication"],
      "affected_users": "All user accounts",
      "business_impact": "User support burden, reputation damage"
    },
    {
      "id": "F-0003",
      "severity": "Medium",
      "confidence": "High",
      "title": "Vector Search LIMIT Parameter Uses Unsafe Type Coercion",
      "description": "Vector search accepts user-supplied limit parameter without strict type validation. Uses Number() conversion which could allow injection if parameter originates from untrusted source. While clamped to max 50, the pattern is unsafe.",
      "impact": "Potential query manipulation if limit parameter passed from untrusted API. Could cause unexpected query behavior or exposure of larger result sets if clamping is bypassed.",
      "files": [
        {
          "path": "server/src/services/vector-search.service.js",
          "start_line": 45,
          "end_line": 50,
          "snippet": "const limitValue = Math.max(1, Math.min(Number(limit) || 5, 50));\nconst results = await prisma.$queryRaw`\n  SELECT * FROM knowledges\n  LIMIT ${limitValue}"
        }
      ],
      "remediation": "Replace Number() coercion with strict integer validation using Zod: z.number().int().min(1).max(50).default(5).parse(limit)",
      "tags": ["validation", "injection", "query", "type-safety"],
      "affected_users": "Knowledge search users",
      "business_impact": "Low - clamping exists but code smell"
    },
    {
      "id": "F-0004",
      "severity": "High",
      "confidence": "High",
      "title": "Missing CSRF Protection on Multiple State-Changing Routes",
      "description": "POST/DELETE operations on team members, integrations, and widget settings lack CSRF token validation. CSRF middleware exists but not applied globally to state-changing operations. Attackers can craft malicious forms to execute unauthorized actions.",
      "impact": "Cross-site request forgery allowing attackers to create/delete team members, modify integrations, or change widget settings on behalf of authenticated users.",
      "files": [
        {
          "path": "server/src/routes/team.routes.js",
          "start_line": 36,
          "end_line": 45,
          "snippet": "router.post('/', authenticateToken, async (req, res) => {\n  // Missing: csrfProtection middleware\n  const { email, role } = req.body;\n  // Directly creates team member without CSRF check"
        },
        {
          "path": "server/src/routes/integrations.routes.js",
          "start_line": 65,
          "end_line": 72,
          "snippet": "router.post('/:integrationId/configure', authenticateToken, async (req, res) => {\n  // Missing CSRF protection\n  // Updates integration configuration directly"
        }
      ],
      "remediation": "Apply CSRF middleware globally to all POST/PUT/DELETE/PATCH routes using app.use(csrfMiddleware) after session middleware, or apply per-route to state-changing operations.",
      "tags": ["security", "csrf", "state-change", "authentication"],
      "affected_users": "All authenticated users",
      "business_impact": "Account compromise, unauthorized business configuration changes"
    },
    {
      "id": "F-0005",
      "severity": "Medium",
      "confidence": "High",
      "title": "Missing Response Size Limits and Pagination in Vector Search",
      "description": "Vector search reranking returns top 3 results without pagination or response size validation. Combined with large knowledge bases and metadata, unbounded JSON response could exceed memory limits or cause slow API responses.",
      "impact": "Memory exhaustion on server during search operations with large result metadata, slow API responses (>10s), potential client-side parsing failures.",
      "files": [
        {
          "path": "server/src/services/vector-search.service.js",
          "start_line": 87,
          "end_line": 95,
          "snippet": "const topResults = rankedResults\n  .slice(0, Math.min(limitValue, 3))\n  .map(r => ({\n    ...r,\n    metadata: r.metadata  // No size limit on metadata\n  }));"
        }
      ],
      "remediation": "Implement response pagination with maxResultSize parameter (max 50KB per response), truncate metadata fields, add limit on metadata object size (max 5KB per result).",
      "tags": ["performance", "memory", "pagination"],
      "affected_users": "Users searching large knowledge bases",
      "business_impact": "Service performance degradation"
    },
    {
      "id": "F-0006",
      "severity": "Medium",
      "confidence": "High",
      "title": "Unhandled Promise Rejection in AI Provider Fallback Logic",
      "description": "AI service attempts multiple providers but error handling incomplete. If all providers fail, errors may not propagate correctly. Some error branches catch and log without rethrowing, causing silent failures.",
      "impact": "Silent failures in AI responses where users receive undefined/null messages instead of proper error messages. Poor UX and potential data loss if fallback silently fails.",
      "files": [
        {
          "path": "server/src/services/ai.service.js",
          "start_line": 375,
          "end_line": 405,
          "snippet": "async function generateResponse(prompt, model) {\n  try {\n    return await groqProvider.chat.completions.create(...);\n  } catch (error) {\n    logger.warn('[HybridAI] Primary failed...');\n    try {\n      return await deepSeekProvider.chat.completions.create(...);\n    } catch (e) {\n      logger.warn('[HybridAI] Backup failed');\n      // Error doesn't propagate - returns undefined\n    }\n  }\n}"
        }
      ],
      "remediation": "Ensure all provider errors are caught, logged, and explicitly re-thrown with descriptive messages. Add unit tests for all-provider-fail scenario with assertions on error messages.",
      "tags": ["error-handling", "async", "fallback"],
      "affected_users": "All chat users when providers fail",
      "business_impact": "Poor error visibility, SLA impact"
    },
    {
      "id": "F-0007",
      "severity": "Low",
      "confidence": "Medium",
      "title": "Use of dangerouslySetInnerHTML with JSON Structured Data",
      "description": "Structured data generation uses dangerouslySetInnerHTML pattern to inject JSON schema. While JSON.stringify is generally safe, pattern could become vulnerable if schema construction changes to include user input.",
      "impact": "Low immediate risk but code smell indicating potential for future XSS vulnerabilities if implementation changes to use user-supplied schema values.",
      "files": [
        {
          "path": "client/src/lib/structured-data.js",
          "start_line": 267,
          "end_line": 270,
          "snippet": "return React.createElement('script', {\n  type: 'application/ld+json',\n  dangerouslySetInnerHTML: { __html: JSON.stringify(schema) }\n});"
        }
      ],
      "remediation": "Replace dangerouslySetInnerHTML with proper text injection: create script element via DOM, set textContent to JSON string, or use serializer library that escapes HTML entities.",
      "tags": ["security", "xss", "frontend", "code-smell"],
      "affected_users": "SEO/structured data users",
      "business_impact": "Low - preventive measure"
    },
    {
      "id": "F-0008",
      "severity": "Critical",
      "confidence": "High",
      "title": "SQL Injection Risk in Vector Search with String Concatenation",
      "description": "Vector search constructs embedding array by string concatenation directly into SQL query. While embedding vector source is API-based, if embedding service is compromised or returns malicious data, SQL injection is possible through the array construction.",
      "impact": "SQL injection allowing unauthorized database access, data theft, or modification. Critical if embedding provider API is compromised or returns invalid data.",
      "files": [
        {
          "path": "server/src/services/vector-search.service.js",
          "start_line": 46,
          "end_line": 56,
          "snippet": "const embeddingArray = `[${embeddingVector.join(',')}]`;\nconst results = await prisma.$queryRaw`\n  SELECT * FROM knowledges \n  WHERE business_id = ${businessId}\n  AND embedding <=> '${embeddingArray}'::vector < ${threshold}\n  LIMIT ${limitValue}`;"
        }
      ],
      "remediation": "Never stringify arrays into SQL. Use Prisma's native vector type support or use parameterized vector literals: use SELECT ... WHERE vector_col <=> $1::vector with driver-level parameterization. Validate embedding array before construction.",
      "tags": ["security", "sql-injection", "database", "critical"],
      "affected_users": "All knowledge search users",
      "business_impact": "Complete database compromise",
      "poc_steps": [
        "1. Compromise or intercept embedding service API",
        "2. Return malicious embedding: [1',NULL--]",
        "3. Resulting query: AND embedding <=> '[1',NULL--]'::vector - injects SQL",
        "4. Extract all knowledge data via OR conditions"
      ]
    },
    {
      "id": "F-0009",
      "severity": "Critical",
      "confidence": "High",
      "title": "Missing Authentication on Webhook Endpoints - No Signature Verification",
      "description": "WhatsApp, Telegram, and Twilio webhook routes accept POST requests without signature validation. Attackers can send forged webhook events to trigger arbitrary actions (create conversations, update statuses, trigger payments).",
      "impact": "Webhook spoofing allowing attackers to create fake conversations, trigger billing events, update conversation statuses, or execute platform actions without legitimate webhook source.",
      "files": [
        {
          "path": "server/src/routes/whatsapp.js",
          "start_line": 38,
          "end_line": 50,
          "snippet": "router.post('/webhook', async (req, res) => {\n  const { messages } = req.body;\n  if (!messages || messages.length === 0) return res.status(200).json({});\n  // No signature verification - directly processes webhook\n  await conversationService.handleMessage(messages[0]);"
        },
        {
          "path": "server/src/routes/telegram.routes.js",
          "start_line": 84,
          "end_line": 95,
          "snippet": "router.post('/webhook/:integrationId', async (req, res) => {\n  // No signature validation\n  const update = req.body;\n  await telegramService.handleUpdate(update, integrationId);"
        },
        {
          "path": "server/src/routes/twilio.routes.js",
          "start_line": 28,
          "end_line": 40,
          "snippet": "router.post('/webhook', async (req, res) => {\n  // Missing Twilio request validation\n  const { From, Body } = req.body;\n  await handleTwilioMessage(From, Body);"
        }
      ],
      "remediation": "Implement provider-specific signature verification: WhatsApp (X-Hub-Signature-256), Telegram (token in URL), Twilio (request validation using twilio-node SDK). Verify before processing any request body.",
      "tags": ["security", "webhook", "auth", "critical"],
      "affected_users": "All webhook-connected businesses",
      "business_impact": "Fake conversations, unauthorized billing, service disruption",
      "poc_steps": [
        "1. Craft malicious JSON payload with fake message",
        "2. Send to /api/whatsapp/webhook via curl/Postman",
        "3. No signature header required - webhook processes immediately",
        "4. Creates fake conversation, triggers AI response, updates analytics"
      ]
    },
    {
      "id": "F-0010",
      "severity": "High",
      "confidence": "High",
      "title": "Missing Rate Limiting on Visitor Analytics Endpoints",
      "description": "GET /api/visitor/analytics, GET /api/visitor/active-sessions, and POST /api/visitor/track-user lack rate limiting. Can be abused for business intelligence enumeration or analytics data poisoning.",
      "impact": "Business intelligence leakage via endpoint enumeration, competitor analytics analysis, analytics data poisoning affecting reporting accuracy.",
      "files": [
        {
          "path": "server/src/routes/visitor.routes.js",
          "start_line": 139,
          "end_line": 145,
          "snippet": "router.get('/analytics', authenticateToken, async (req, res) => {\n  const { businessId } = req.query;\n  // No rate limiting - user can request analytics unlimited times\n  const analytics = await visitorService.getAnalytics(businessId);"
        },
        {
          "path": "server/src/routes/visitor.routes.js",
          "start_line": 166,
          "end_line": 172,
          "snippet": "router.post('/track-user', authenticateToken, async (req, res) => {\n  // No rate limiting - can poison analytics with unlimited data\n  const { visitorId, pageView } = req.body;\n  await visitorService.trackPageView(visitorId, pageView);"
        }
      ],
      "remediation": "Apply rate limiting middleware to analytics endpoints: 100 requests/hour per authenticated user, 50 requests/hour for tracking endpoints to prevent analytics poisoning.",
      "tags": ["security", "rate-limit"],
      "affected_users": "Users with analytics access",
      "business_impact": "Competitive intelligence leakage"
    },
    {
      "id": "F-0011",
      "severity": "High",
      "confidence": "High",
      "title": "No Explicit Request Size Limits on File Upload Endpoints",
      "description": "Knowledge base and widget icon upload endpoints lack explicit multer size limit configuration. Attackers can upload arbitrarily large files causing disk exhaustion and out-of-memory errors.",
      "impact": "Denial of service via large file uploads, disk space exhaustion, OOM crashes, server unavailability.",
      "files": [
        {
          "path": "server/src/routes/knowledge.routes.js",
          "start_line": 31,
          "end_line": 35,
          "snippet": "const upload = multer({ dest: 'uploads/knowledge' });\nrouter.post('/upload', authenticateToken, (req, res, next) => {\n  upload.single('file')(req, res, next);\n  // No fileSize limit configured"
        },
        {
          "path": "server/src/routes/widget.routes.js",
          "start_line": 173,
          "end_line": 177,
          "snippet": "router.post('/upload-icon', authenticateToken, upload.single('icon'), async (req, res) => {\n  // upload multer instance not configured with limits\n  const file = req.file;"
        }
      ],
      "remediation": "Configure multer with explicit limits: fileSize: 10*1024*1024 (10MB max), fieldNameSize: 100, files: 1. Add validators to check file types (whitelist .pdf, .docx, .jpg, etc).",
      "tags": ["security", "file-upload", "dos"],
      "affected_users": "Knowledge base and widget users",
      "business_impact": "Service availability"
    },
    {
      "id": "F-0012",
      "severity": "Medium",
      "confidence": "High",
      "title": "JWT Secret Validation Shows Inconsistency Between Config Layers",
      "description": "JWT secret enforcement differs between config layers: env.validator.js requires >= 48 chars for production, but env.js only warns if < 32 chars. Creates gap where 32-48 char secrets could pass one check but fail another.",
      "impact": "Production deployments with weak JWT secrets (32-47 chars) may pass initial validation but fail under stricter security policies. Inconsistent security posture.",
      "files": [
        {
          "path": "server/src/config/env.validator.js",
          "start_line": 29,
          "end_line": 32,
          "snippet": "JWT_SECRET: z.string()\n  .min(48, { \n    message: 'JWT_SECRET must be at least 48 characters for production security'\n  }),"
        },
        {
          "path": "server/src/config/env.js",
          "start_line": 34,
          "end_line": 37,
          "snippet": "if (process.env.JWT_SECRET.length < 32) {\n  logger.warn('JWT_SECRET is less than 32 characters - security risk');\n  // Only warns, doesn't enforce"
        }
      ],
      "remediation": "Enforce 48-character minimum uniformly in both validator and config layers. Generate secrets using: openssl rand -base64 48. Update documentation requiring 48-char minimum for all environments.",
      "tags": ["security", "jwt", "config"],
      "affected_users": "Production deployments",
      "business_impact": "Weak cryptographic keys"
    },
    {
      "id": "F-0013",
      "severity": "Medium",
      "confidence": "High",
      "title": "Missing Timeout Configuration on External API Calls",
      "description": "Axios calls to embedding providers (Gemini, Voyage, OpenAI) in embedding.service.js lack timeout configuration. Slow or hanging providers can block requests indefinitely, exhausting connection pool.",
      "impact": "Resource leak and connection pool exhaustion when embedding providers respond slowly or hang. Server becomes unresponsive to new requests.",
      "files": [
        {
          "path": "server/src/services/embedding.service.js",
          "start_line": 1,
          "end_line": 120,
          "snippet": "const response = await axios.post(\n  `${VOYAGE_API_URL}/embeddings`,\n  { model: 'voyage-2', input: text },\n  { headers: { Authorization: `Bearer ${VOYAGE_API_KEY}` } }\n  // Missing: timeout configuration\n);"
        }
      ],
      "remediation": "Set timeout to 15-30 seconds on all axios calls: axios.post(url, data, { timeout: 15000, headers: {...} }). Implement circuit breaker pattern for failing providers.",
      "tags": ["performance", "timeout", "integration"],
      "affected_users": "All chat users when embedding provider is slow",
      "business_impact": "Service latency and resource exhaustion"
    },
    {
      "id": "F-0014",
      "severity": "High",
      "confidence": "High",
      "title": "Open Redirect Vulnerability in Proxy Routes",
      "description": "POST /api/proxy/chat/message accepts user-supplied endpoint URLs without validation. Attackers can redirect API responses to attacker-controlled servers for man-in-the-middle attacks.",
      "impact": "Man-in-the-middle attacks, credential theft, response manipulation, sensitive data interception.",
      "files": [
        {
          "path": "server/src/routes/proxy.routes.js",
          "start_line": 13,
          "end_line": 35,
          "snippet": "router.post('/chat/message', async (req, res) => {\n  const { endpoint, payload } = req.body;\n  // No validation - accepts arbitrary URL\n  const response = await axios.post(endpoint, payload);\n  res.json(response.data);"
        }
      ],
      "remediation": "Validate endpoint URLs against whitelist of allowed domains. Do not allow arbitrary URL proxying. Use URL parser to verify scheme (https only) and domain matches whitelist.",
      "tags": ["security", "open-redirect", "proxy"],
      "affected_users": "Proxy route users",
      "business_impact": "MITM attacks on sensitive data"
    },
    {
      "id": "F-0015",
      "severity": "Critical",
      "confidence": "High",
      "title": "Unrestricted Demo Login Creates Unlimited Accounts Without Rate Limiting",
      "description": "POST /api/auth/demo-login creates test accounts without rate limiting or environment checks. Attackers can create unlimited demo accounts causing resource exhaustion or enumeration of business types.",
      "impact": "Unlimited account creation, database quota exhaustion, server resource depletion, enumeration of supported business types, testing infrastructure abuse.",
      "files": [
        {
          "path": "server/src/routes/auth.routes.js",
          "start_line": 27,
          "end_line": 28,
          "snippet": "router.post('/demo-login', asyncHandler(authController.demoLogin));\n// No rate limiting, no NODE_ENV check"
        }
      ],
      "remediation": "Remove /demo-login from production or restrict to development-only environment (check NODE_ENV === 'development'). If kept for testing, add strict rate limiting: max 10 per hour per IP.",
      "tags": ["security", "dos", "auth", "critical"],
      "affected_users": "All platform users (resource exhaustion impact)",
      "business_impact": "Service availability, infrastructure costs",
      "poc_steps": [
        "1. Loop: curl -X POST http://server/api/auth/demo-login 10,000 times",
        "2. Creates 10,000 accounts in seconds",
        "3. Database quota exceeded",
        "4. Server unresponsive"
      ]
    },
    {
      "id": "F-0016",
      "severity": "Medium",
      "confidence": "High",
      "title": "Unvalidated Knowledge Base Content Allows Stored XSS",
      "description": "Knowledge base text/URL content is stored in database without sanitization. If rendered in frontend without escaping, triggers stored XSS affecting users who view the knowledge.",
      "impact": "Stored XSS attack allowing account compromise when knowledge is displayed to other users (team members, support staff).",
      "files": [
        {
          "path": "server/src/routes/knowledge.routes.js",
          "start_line": 43,
          "end_line": 44,
          "snippet": "router.post('/text', authenticateToken, resolveBusinessId, validateAddTextKnowledge, knowledgeController.addTextKnowledge);\n// No sanitization of content before storage"
        },
        {
          "path": "server/src/controllers/knowledge.controller.js",
          "start_line": 1,
          "end_line": 50,
          "snippet": "async function addTextKnowledge(req, res) {\n  const { title, content } = req.body;\n  // Content stored directly without sanitization\n  const knowledge = await prisma.knowledge.create({\n    data: { title, content, businessId }\n  });"
        }
      ],
      "remediation": "Sanitize all user-submitted text content using sanitize-html library before storing in database: const clean = sanitizeHtml(content, {allowedTags: ['b', 'i', 'br']})",
      "tags": ["security", "xss", "sanitization"],
      "affected_users": "Team members viewing knowledge base",
      "business_impact": "Account compromise"
    },
    {
      "id": "F-0017",
      "severity": "Medium",
      "confidence": "High",
      "title": "Duplicate Service Logic Between Analytics Files",
      "description": "visitor.service.js and visitor-session.service.js implement identical analytics aggregation logic (reduce, map, filter operations). Nearly 100% code duplication for session metrics calculation.",
      "impact": "Code maintenance burden; bug fixes applied to one file but not the other; inconsistent analytics calculations; increased development time.",
      "files": [
        {
          "path": "server/src/services/visitor.service.js",
          "start_line": 285,
          "end_line": 295,
          "snippet": "getAnalyticsSummary(sessions) {\n  return {\n    totalPageViews: sessions.reduce((sum, s) => sum + s.pageViews, 0),\n    totalSessions: sessions.length,\n    avgSessionDuration: sessions.reduce((sum, s) => sum + s.duration, 0) / sessions.length,"
        },
        {
          "path": "server/src/services/visitor-session.service.js",
          "start_line": 360,
          "end_line": 370,
          "snippet": "getAnalyticsSummary(sessions) {\n  return {\n    totalPageViews: sessions.reduce((sum, s) => sum + s.pageViews, 0),\n    totalSessions: sessions.length,\n    avgSessionDuration: sessions.reduce((sum, s) => sum + s.duration, 0) / sessions.length,"
        }
      ],
      "remediation": "Extract shared analytics logic to utils/analytics-helpers.js or merge both services into single visitor-analytics.service.js with clear separation of concerns.",
      "tags": ["code-quality", "duplication", "maintenance"],
      "affected_users": "Development team",
      "business_impact": "Maintenance cost"
    },
    {
      "id": "F-0018",
      "severity": "Low",
      "confidence": "High",
      "title": "Inefficient String.indexOf() in Logging Level Comparison",
      "description": "logger.js uses indexOf() in loop for log level comparison. Should use array.includes() or switch statement for better readability and minor performance improvement.",
      "impact": "Minor performance impact on high-volume logging (O(n) instead of O(1) for level check); code clarity issue.",
      "files": [
        {
          "path": "server/src/utils/logger.js",
          "start_line": 34,
          "end_line": 34,
          "snippet": "return levels.indexOf(level) <= levels.indexOf(this.logLevel);"
        }
      ],
      "remediation": "Replace with switch statement or Map for O(1) lookup, or use includes(): const LOG_LEVELS = { error: 0, warn: 1, info: 2, debug: 3 }; return LOG_LEVELS[level] <= LOG_LEVELS[this.logLevel]",
      "tags": ["performance", "code-quality"],
      "affected_users": "Development team",
      "business_impact": "Negligible"
    },
    {
      "id": "F-0019",
      "severity": "Medium",
      "confidence": "High",
      "title": "Missing Pagination on Knowledge Base Search Results",
      "description": "Knowledge search endpoint returns all matching results without limit/offset parameters. Large knowledge bases can return 1000s of results causing excessive network bandwidth and slow responses.",
      "impact": "Slow search responses (>5s), excessive network bandwidth usage, poor frontend UX when displaying 1000+ items, potential memory issues on client.",
      "files": [
        {
          "path": "server/src/routes/knowledge-base.routes.js",
          "start_line": 55,
          "end_line": 70,
          "snippet": "router.get('/search', authenticateToken, resolveBusinessId, async (req, res) => {\n  const { query } = req.query;\n  const results = await knowledgeService.search(businessId, query);\n  // Returns all results - no pagination\n  res.json(results);"
        }
      ],
      "remediation": "Add limit/offset parameters with defaults (limit: 20, max 100, default offset: 0). Implement cursor-based pagination for better performance on large datasets.",
      "tags": ["performance", "pagination"],
      "affected_users": "Users with large knowledge bases",
      "business_impact": "Search performance degradation"
    },
    {
      "id": "F-0020",
      "severity": "High",
      "confidence": "High",
      "title": "Missing URL Validation in Knowledge Base URL Ingestion - SSRF Risk",
      "description": "Knowledge.addUrlKnowledge() accepts arbitrary URLs without protocol/domain validation. Attacker can supply local URLs (file://, http://localhost, internal IP ranges) for server-side request forgery attack.",
      "impact": "Server-side request forgery (SSRF) allowing access to internal services, metadata endpoints, local files, and internal-only APIs (e.g., 169.254.169.254 AWS metadata).",
      "files": [
        {
          "path": "server/src/routes/knowledge.routes.js",
          "start_line": 46,
          "end_line": 50,
          "snippet": "router.post('/url', authenticateToken, resolveBusinessId, validateAddUrlKnowledge, knowledgeController.addUrlKnowledge);\n// No URL validation - accepts any URL\nconst { url } = req.body;\nawait crawler.fetchUrl(url);  // SSRF vulnerability"
        }
      ],
      "remediation": "Validate URLs with whitelist of allowed schemes (https only, block localhost/127.0.0.1/::1/169.254.x.x/10.0.0.0-10.255.255.255). Use URL parser and network range validator before fetching.",
      "tags": ["security", "ssrf", "validation"],
      "affected_users": "Knowledge base users",
      "business_impact": "Internal system access"
    }
  ],
  "top20": [
    "F-0008",
    "F-0009",
    "F-0015",
    "F-0001",
    "F-0004",
    "F-0002",
    "F-0011",
    "F-0014",
    "F-0020",
    "F-0016",
    "F-0010",
    "F-0006",
    "F-0003",
    "F-0019",
    "F-0012",
    "F-0017",
    "F-0013",
    "F-0005",
    "F-0007",
    "F-0018"
  ],
  "statistics": {
    "total_findings": 20,
    "by_severity": {
      "Critical": 2,
      "High": 9,
      "Medium": 7,
      "Low": 2
    },
    "by_category": {
      "security": 14,
      "validation": 3,
      "performance": 4,
      "code-quality": 2,
      "error-handling": 1
    },
    "by_layer": {
      "backend": 18,
      "frontend": 2,
      "cross-layer": 0
    }
  },
  "api_endpoints_analyzed": 45,
  "routes_missing_validation": 8,
  "routes_missing_rate_limiting": 6,
  "routes_missing_auth": 3,
  "components_with_duplication": 4,
  "services_with_duplication": 2,
  "n_plus_one_queries_found": 3,
  "false_positives": [
    {
      "location": "server/src/services/ai.service.js",
      "suspicious_pattern": "Function constructor for dynamic module check",
      "reason": "Intentional feature detection, not security risk",
      "verified": true
    },
    {
      "location": "server/src/utils/encryption.js",
      "suspicious_pattern": "'password' in comments",
      "reason": "Legitimate documentation of password fields, not hardcoded secret",
      "verified": true
    }
  ],
  "remediation_roadmap": {
    "phase_1_critical_24h": [
      "F-0008",
      "F-0009",
      "F-0015"
    ],
    "phase_2_high_1week": [
      "F-0001",
      "F-0002",
      "F-0004",
      "F-0011",
      "F-0014",
      "F-0020"
    ],
    "phase_3_medium_2weeks": [
      "F-0003",
      "F-0005",
      "F-0006",
      "F-0010",
      "F-0012",
      "F-0016",
      "F-0019"
    ],
    "phase_4_low_3weeks": [
      "F-0007",
      "F-0013",
      "F-0017",
      "F-0018"
    ]
  },
  "verification_commands": {
    "sql_injection": "grep -n \"embeddingArray\" server/src/services/vector-search.service.js",
    "hardcoded_secrets": "rg '(password|secret|token|key)\\s*=\\s*[\\'\\\"' --type js server/src",
    "rate_limiting": "grep -n 'rateLimit\\|RateLimit' server/src/routes/*.js",
    "auth_checks": "grep -n 'authenticateToken\\|requireAuth' server/src/routes/*.js",
    "unhandled_promises": "grep -n 'catch(' server/src/**/*.js",
    "npm_audit": "npm audit --audit-level=moderate"
  },
  "generated_timestamp": "2025-12-16T00:00:00Z",
  "report_version": "1.0"
}
